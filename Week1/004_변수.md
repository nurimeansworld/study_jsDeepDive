## 변수
---
### 목록
1. 변수란 무엇인가? 왜 필요한가?
2. 식별자란?
3. 변수 선언의 종류는?
4. 변수 선언의 실행 시점과 변수 호이스팅(let,const의 존재 이유)
5. 값의 할당
6. 식별자 네이밍 규칙이란?

---

### 4.1 변수란 무엇인가? 왜 필요한가? 

`10 + 20` 이라는 코드를 자바스크립트가 계산하려면
자바스크립트 엔진이 `10` `20` 인 리터럴(문자 그대로의) 과 `+` (연산자) 의 의미를 알고 있어야 하고 
`10 + 20` 인 표현식의 의미를 파싱할 수 있어야 한다. 

연산을 수행하기 위해 `+` 연산자의 좌변과 우변의 숫자 값 <b>(피연산자 operand)</b>을 메모리셀에 기억한다.

`CPU - Central Processing Unit` 로 직역하면 중앙처리장치로 컴퓨터의 정중앙에서 모든 데이터를 처리하는 장치이다. 컴퓨터의 두뇌에 해당, 사용자로부터 입력 받은 명령어를 해석, 연산한 후 그 결과를 출력하는 역할을 한다.

이 `cpu`로 연산하고 
메모리를 사용해 데이터를 기억한다. 
- 메모리 셀 : 데이터를 저장하는 공간으로 하나 당 `1byte(8bits)`의 크기를 가짐 
- 즉, 1바이트 단위로 데이터를 저장
- 이 셀의 집합이 메모리 
- 숫자의 경우, 숫자 상관없이 1 이드 100000 상관없이 모두 8바이트 
- 문자열의 경우,문자 길이에 따라서 바이트 메모리 

> 즉, 위의 10 + 20 를 계산하기 위해 컴퓨터는 
10 과 20 인 피연산자(operand) 를  메모리셀에 저장하고,
cpu로 연산한 뒤, 결과값 30을 메모리 셀 안에 저장한다.
따라서 이 결과값을 재사용하기위해 변수를 지정해준다. 

만약 변수를 지정해주지 않고 이 값을 재사용하기 위해서는 메모리 주소에 접근해줘야 하는데, 메모리 주소에 접근을 할 수 없을 뿐더러 접근 하더라도 메모리 주소는 메모리 상황에 따라 임의 결정되기 때문에, 오류가 발생한다.

따라서 저장된 값을 재사용 하기 위해서는 변수를 사용한다. 

변수는 본래 하나의 값을 저장하기 위한 메커니즘이며, 여러개의 값을 저장하려면 배열이나 객체 같은 자료구조를 사용하여 여러 값을 그룹화하여 하나의 값처럼 사용할 수 있다. 

### 4.2 식별자 

- 식별자는 변수 값( 30 )을 저장하는게 아니라 ,, 값 30이 저장된 <b>메모리 주소</b>를 기억한다.
즉, 식별자와 메모리 주소는 매핑 관계며, 이 매핑 정보도 메모리에 저장된다.

- 식별한다는 것은 식별자가 기억하는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근한다는 의미이다.
식별자는 변수 뿐만 아니라 함수,클래스 등 메모리 상에 존재하는 어떤 값을 식별하는 것은 모두 식별자이다. 

### 4.3 변수 선언 

변수 선언이란 ?

> 값을 저장하기 위한 메모리 공간을 확보 후, 변수 이름과 확보된 공간의 주소를 연결 

이 확보된 공간을 해제되기 전까진 사용할 수 없도록 보호된다. 

변수 선언 키워드에는 `var, let, const` 를 사용하는데 
let, const는 ES6 에서 도입되었고 이 전까진 var 가 유일한 변수 선언 키워드였다.
하지만 var는 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다는 점인데 이로인해 의도치 않은 전역변수가 선언되어 부작용이 발생한다. 

#### `함수레벨 스코프?`
함수 레벨 스코프는 함수 밖에서 선언한 함수 스코프 변수는 전역 범위를 가지고, 함수 안에서 사용하면 함수 밖을 제외한 내부 어디서든 접근이 가능하다. 
변수 a 는 함수 밖에서 선언하였음로 전역변수
변수 b와 c는 function foo내에서 선언하였으므로 함수 bar에서는 접근이 불가능하다. 
변수 d는 함수 bar 내에서 선언하였으므로 출력이 가능하다. 

```js
var a = "I'm a";
function foo() {
    var b = "I'm b";
    console.log(a);        //I'm a - 전역변수. 출력가능.
    if(true) {
        var c = "I'm c";
        console.log(b);    //I'm b - 해당 함수 내 선언한 변수. 출력 가능.
    }
    console.log(c);        //I'm c - 해당 함수 내 선언한 변수. 출력 가능.
}
foo();
function bar() {
    var d = "I'm d";
    console.log(d);    //I'm d - 해당 함수 내 선언한 변수. 출력 가능.
    console.log(a);    //전역변수. 출력가능.
    console.log(b);    //해당 함수 내 선언한 변수가 아님. Error
    console.log(c);    //해당 함수 내 선언한 변수가 아님. Error
}
bar();
```

함수 레벨 스코프는 
메모리 누수, 디버깅이 어렵고 가독성이 떨어진다는 문제점이 있다.
이러한 문제점을 피하고자 블록 스코프 변수를 생성하기 위한 let, const 키워드가 탄생하였다.

#### `블록 레벨 스코프란? - let, const`

블록은 0개 이상의 구문(statement)을 묶기위해 사용하고, 중괄호{}로 경계를 구분한다.
블록 스코프 변수는 함수 밖에서 선언하면 함수 스코프 변수처럼 전역 접근할 수 있습니다. 블록 안에서 선언하면 자신을 정의한 블록과 하위 블록에서만 접근이 가능하다.

Foo 라는 변수를 선언하고 변수 값(i'm foo)를 할당해주었고 이는 함수 밖에서 선언 하였으므로 전역 변수이다. 
함수 내에서 변수 bar를 선언해주고 이는 블록 안에서 선언하였으므로 
블록 밖에서는 전역변수인 foo 만 접근이 가능하고 bar는 불가하다. 
 
```js
let foo = "I'm foo";
if(true) {
    let bar = "I'm bar";
    console.log(foo);   //I'm foo
    console.log(bar);   //I'm bar
}

console.log(foo);   //I'm foo
console.log(bar);   //Uncaught ReferenceError: bar is not defined.


변수재선언 
var 키워드로 선언된 변수는 재선언이 가능하다.

var a = 0;
var a = 1;
console.log(a); //1
function foo() {
    var b = 2;
    var b = 3;  //3
    console.log(b);
}
하지만 let 키워드로 선언된 변수는 재선언이 불가능하다.
let a = 0;
let a = 1;      //error

if(true) {
    let b = 2;
    let b = 3;     
    console.log(b); //error
}
```

위 코드로 변수 이름을 score로 등록하고(변수 이름은 실행 컨텍스트에 등록됨) 앞으로의 할당해줄 값을 저장할 메모리 공간이 확보되었다. 아직 할당 전이므로 공간엔 undefinde(원시 타입의 값) 가 할당되어 초기화된다. 

`변수 선언의 단계` 
1단계 선언 단계 : 변수 이름 등록해서 존재 알리기
2단계 초기화 단계 : 메모리 공간 확보해서 암묵적으로 undefined 를 할당해 초기화. 

>var 키워드의 경우 

이 두 단계가 동시에 진행되므로 선언과 동시에 자동으로 초기화가 된다. 초기화란 선언 이후 최초로 값을 할당하는 것을 뜻한다. 초기화를 하지 않으면 쓰레기 값이 남게된다. 그러므로 할당하지 않고 바로 변수 값을 참조하면 쓰레기 값이 나오므로 var 키워드의 경우엔 이런 위험으로부터 안전하다.


### 4.4 변수 선언의 실행 시점과 변수 호이스팅 

호이스팅이란 함수 안의 변수 선언을 모두 최상단으로 끌어 올려주는 JS 고유의 독특한 기능이다.

위의 예제는 변조 참조문이 변수 선언문을 앞선 상황인데,
 console.log(score); 인 이 변수 참조문에서 참조에러가 발생하지 않고 undefined 가 뜨는 이유는  변수 선언은 인터프리터 되는 시점인 런타임보다 이전에 실행 되기 때문에 
자바스크립트의 호이스팅 기능으로 var score;가 최상단으로 호이스팅 되었기 때문에 undefined 값이 뜬다. 


### 4.5 값의 할당 

`할당연산자  -> = `

우변의 값을 좌변의 변수에 할당하는 기능.
변수 선언은 런타임 이전에 먼저 실행하지만
값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다. 

```js
예제  04 - 10

console.log(score); //undefined

Score = 80; // 할당
Var score;

console.log(score); // ??? 
```

04-10 예제에서는 선언 이후 할당이 아닌, 80으로 할당을 먼저 해주고 선언을 해주었는데 내 예상대로 undefined 가 나왔다. 재할당과 마찬가지로 선언을 새롭게 해주면 본 메모리 공간이 아닌 메모리 공간이 새롭게 확보되면서 score 변수는 새 공간에서 다시 할당 전 상태로 초기화되어 undefined 값을 가지게 되는 것이다. 

### 4.6 값의 재할당

ES6에서 도입된 `const` 키워드는 재할당이 금지된다. 즉, 한 번만 할당이 가능하므로 const는 상수를 표현할 수 있다. 하지만 const 가 상수만을 위한 표현은 아니다.  

재할당은 현재 변수에 저장된 값을 버리고 새로운 메모리 공간을 확보해서 새로운 값을 저장하는 것. 원래의 메모리 공간을 지우진 않으며 재할당 전의 불필요한 값은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 언제 해제되는지는 예측불가.

`가비지 콜렉터 ? `

- 메모리 공간을 주기적으로 검사하여 어떤 식별자와도 참조하지 메모리를 해제하는 기능. 메모리 누수를 방지한다. 

### 4.7 식별자 네이밍 규칙

`문자,숫자, $(달러), _(언더스코어)` 를 제외한 나머지 특수문자는 포함할 수 없다. 
식별자의 시작은 숫자는 허용하지 않는다.
예약어는 사용할 수 없다.

```js
예약어 종류

await
break 
case catch class const continue 
debugger default dlelete do 
else enum export extends 
false finally for function 
if implement* import in instanceof interface* 
let* 
new null 
package* private* protected* public* 
return 
super static* swich 
this throw tre try typeof 
var void 
while with 
yield* 
```

유니코드를 허용하므로 한글, 일본어도 사용 가능하다.

대소문자를 구별하므로 모두 별개의 변수다.
```js
var firstName; 
var firstname;
var FIRSTNAME;
```

네이밍 컨밴션 4가지 

일반적인 변수나 함수에는 카멜케이스 

`var firstName;`

2. 생성자 함수, 클래스의 이름에는 파스칼 케이스 

`var FirstName;`

3. 스네이크 케이스

`var first_name;`

4. 헝가리언 케이스
```js
var strFirstName; //type + identifier
var $elem = documet.getElementById('myID'); //DOM노드
var observable$ = fromEvent(document, 'click'); //RxJS 옵저버블 
```
